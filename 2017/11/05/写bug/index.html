<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>写bug | duuliy</title><meta name="description" content="容易输入的名字。比如：Fred，asdf..."><meta name="generator" content="duuliy"><meta name="author" content="duuliy"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/logo.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/logo.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/logo.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/logo.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/logo.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/logo.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/logo.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/logo.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="logo.png"><meta name="msapplication-square70x70logo" content="logo.png"><meta name="msapplication-square150x150logo" content="logo.png"><meta name="msapplication-wide310x150logo" content="logo.png"><meta name="msapplication-square310x310logo" content="logo.png"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="duuliy" title="duuliy" itemprop="headline">duuliy</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="主页" title="主页" itemprop="url">主页</a></li><li itemprop="name"><a href="/archives" alt="归档" title="归档" itemprop="url">归档</a></li><li itemprop="name"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="theme-by text-muted">Theme by
<a target="_blank" rel="noopener" href="https://github.com/mkkhedawat/clexy">clexy-hexo</a></p><p class="copyright text-muted">© duuliy • 2025</p></div></div></div></footer><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">写bug</h1><span class="post-meta"></span><span class="page-tag-anchor">2017-11-5</span><br><br><p>容易输入的名字。比如：Fred，asdf<br>单字母的变量名。比如：a,b,c, x,y,z（陈皓注：如果不够用，可以考虑a1,a2,a3,a4,….）<br>有创意地拼写错误。比如：SetPintleOpening， SetPintalClosing。这样可以让人很难搜索代码。<br>抽象。比如：ProcessData, DoIt, GetData… 抽象到就跟什么都没说一样。<br>缩写。比如：WTF，RTFSC …… （陈皓注：使用拼音缩写也同样给力，比如： BT，TMD，TJJTDS）<br>随机大写字母。比如：gEtnuMbER..<br>重用命名。在内嵌的语句块中使用相同的变量名有奇效。<br>使用重音字母。比如：int  ínt（注：第二个 ínt不是int）<br>使用下划线。比如：_, __, ___。<br>使用不同的语言。比如混用英语，德语，或是中文拼音。<br>使用字符命名。比如：slash, asterix, comma…<br>使用无关的单词。比如：god, superman, iloveu….<br>混淆l和1。字母l和数字1有时候是看不出来的。<br>伪装欺诈<br>把注释和代码交织在一起。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>array_len<span class="token punctuation">;</span> j<span class="token operator">+</span> <span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    total <span class="token operator">+</span><span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
    total <span class="token operator">+</span><span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
    total <span class="token operator">+</span><span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">2</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Main body of
    total += array[j+3]; * loop is unrolled
    total += array[j+4]; * for greater speed.
    total += array[j+5]; */</span>
    total <span class="token operator">+</span><span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">6</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
    total <span class="token operator">+</span><span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">7</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>隐藏宏定义。如：#define a=b a=0-b，当人们看到a=b时，谁也想不到那是一个宏。<br>换行。如下所示，下面的示例使用搜索xy_z变得困难。<br>#define local_var xy<br>_z // local_var OK<br>代码和显示不一致。比如，你的界面显示叫postal code，但是代码里确叫 zipcode.<br>隐藏全局变量。把使用全局变量以函数参数的方式传递给函数，这样可以让人觉得那个变量不是全局变量。<br>使用同意词。如：<br>#define xxx global_var // in file std.h<br>#define xy_z xxx // in file ..\other\substd.h<br>#define local_var xy_z // in file ..\codestd\inst.h<br>使用相似的变量名。如：单词相似，swimmer 和 swimner，字母相似：ilI1| 或 oO08。parselnt 和 parseInt， D0Calc 和 DOCalc。还有这一组：xy_Z, xy__z, _xy_z, _xyz, XY_Z, xY_z, Xy_z。<br>重载函数。使用相同的函数名，但是其功能和具体实现完全没有关系。<br>操作符重载。重载操作符可以让你的代码变得诡异，感谢CCTV，感谢C++。这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 ! 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 ! ! 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。<br>#define。看过本站那些混乱代码的文章，你都会知道宏定义和预编译对于写出不可读的代码的重大意义。不过，一个具有想像力的东西是——在头文件中使用预编译来查看这个头文件被include了几次，而被include不同的次数时，其中的函数定义完全不一样。</p>
<pre class=" language-js"><code class="language-js">#ifndef DONE
#ifdef TWICE
<span class="token comment" spellcheck="true">// put stuff here to declare 3rd time around</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span>char<span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
#define DONE
#<span class="token keyword">else</span> <span class="token comment" spellcheck="true">// TWICE</span>
#ifdef ONCE
<span class="token comment" spellcheck="true">// put stuff here to declare 2nd time around&lt;</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
#define TWICE
#<span class="token keyword">else</span> <span class="token comment" spellcheck="true">// ONCE</span>
<span class="token comment" spellcheck="true">// put stuff here to declare 1st time around</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>string str<span class="token punctuation">)</span><span class="token punctuation">;</span>
#define ONCE
#endif <span class="token comment" spellcheck="true">// ONCE</span>
#endif <span class="token comment" spellcheck="true">// TWICE</span>
#endif <span class="token comment" spellcheck="true">// DONE</span></code></pre>
<p>文档和注释<br>在注释中撒谎。你不用真的去撒谎，只需在改代码的时候不要更新注释就可以了。<br>注释明显的东西。比如：/* add 1 to i <em>/。（参看本站的“五种应该避免的注释”）<br>只注释是什么，而不是为什么。<br>不要注释秘密。如果你开发一个航班系统，请你一定要保证每有一个新的航班被加入，就得要修改25个以上的位置的程序。千万别把这个事写在文档中。<br>注重细节。当你设计一个很复杂的算法的时候，你一定要把所有的详细细设计都写下来，没有100页不能罢休，段落要有5级以上，段落编号要有500个以上，例如：1.2.4.6.3.13 – Display all impacts for activity where selected mitigations can apply (short pseudocode omitted). 这样，当你写代码的时候，你就可以让你的代码和文档一致，如：Act1_2_4_6_3_13()<br>千万不要注释度衡单位。比如时间用的是秒还是毫秒，尺寸用的是像素还是英寸，大小是MB还是KB。等等。另外，在你的代码里，你可以混用不同的度衡单位，但也不要注释。<br>Gotchas。陷阱，千万不要注释代码中的陷阱。<br>在注释和文档中发泄不满。（参看本站的“五种应该避免的注释”）<br>程序设计<br>Java Casts。Java的类型转型是天赐之物。每一次当你从Collection里取到一个object的时候，你都需要把其转回原来的类型。因些，这些转型操作会出现在N多的地方。如果你改变了类型，那么你不一定能改变所有的地方。而编译器可能能检查到，也可能检查不到。<br>利用Java的冗余。比如：Bubblegum b = new Bubblegom(); 和 swimmer = swimner + 1; 注意变量间的细微差别。<br>从不验证。从不验证输入的数据，从不验证函数的返回值。这样做可以向大家展示你是多么的信任公司的设备和其它程序员。<br>不要封装。调用者需要知道被调用的所有的细节。<br>克隆和拷贝。为了效率，你要学会使用copy + paste。你几乎都不用理解别人的代码，你就可以高效地编程了。（陈皓注：Copy + Paste出来的代码bug多得不能再多）<br>巨大的listener。写一个listener，然后让你的所有的button类都使用这个listener，这样你可以在这个listener中整出一大堆if…else…语句，相当的刺激。<br>使用三维数组。如果你觉得三维还不足够，你可以试试四维。<br>混用。同时使用类的get/set方法和直接访问那个public变量。这样做的好处是可以极大的挫败维护人员。<br>包装，包装，包装。把你所有的API都包装上6到8遍，包装深度多达4层以上。然后包装出相似的功能。<br>没有秘密。把所有的成员都声明成public的。这样，你以后就很难限制其被人使用，而且这样可以和别的代码造成更多的耦合度，可以让你的代码存活得更久。<br>排列和阻碍。把drawRectangle(height, width) 改成 drawRectangle(width, height)，等release了几个版本后，再把其改回去。这样维护程序的程序员们将不能很快地明白哪一个是对的。<br>把变量改在名字上。例如，把setAlignment(int alignment)改成，setLeftAlignment, setRightAlignment, setCenterAlignment。<br>Packratting。保留你所有的没有使用的和陈旧的变量，方法和代码。<br>That’s Final。Final你所有的子结点的类，这样，当你做完这个项目后，没有人可以通过继承来扩展你的类。java.lang.String不也是这样吗？<br>避免使用接口。在java中，BS接口，在C++中BS使用虚函数。<br>避免使用layout。这样就使得我们只能使用绝对坐标。如果你的老大强制你使用layout，你可以考虑使用GridBagLayout，然后把grid坐标hard code.<br>环境变量。如果你的代码需要使用环境变量。(getenv() – C++ / System.getProperty() – Java )，那么，你应该把你的类的成员的初始化使用环境变量，而不是构造函数。<br>使用Magic number。参看《Linux一个插曲》。<br>使用全局变量。1）把全局变量的初始化放在不同的函数中，就算这个函数和这个变量没有任何关系，这样能够让我们的维护人员就像做侦探工作一样。2）使用全局变量可以让你的函数的参数变得少一些。<br>配置文件。配置文件主要用于一些参数的初始化。在编程中，我们可以让配置文件中的参数名和实际程序中的名字不一样。<br>膨胀你的类。让你的类尽可能地拥有各种臃肿和晦涩的方法。比如，你的类只实现一种可能性，但是你要提供所有可能性的方法。不要定义其它的类，把所有的功能都放在一个类中。<br>使用子类。面向对象是写出无法维护代码的天赐之物。如果你有一个类有十个成为（变量和方法）你可以考虑写10个层次的继承，然后把这十个属性分别放在这十个层次中。如果可能的话，把这十个类分别放在十个不同的文件中。<br>混乱你的代码<br>使用XML。XML的强大是无人能及的。使用XML你可以把本来只要10行的代码变成100行。而且，还要逼着别人也有XML。（参看，信XML得永生，信XML得自信）<br>混乱C代码。在《如何加密源代码》中已经说过一些方法了，这里再补充一些。<br>使用不同的进制。比如：10 和010不是一样的。再比如：array = new int[]{   111,   120,   013,   121,};<br>尽量使用void</em>。然后把其转成各种类型<br>使用隐式的转型。C++的构造函数可以让你神不知鬼不觉得完成转型。<br>分解条件表达式。如：把 a==100分解成，a&gt;99 &amp;&amp; a&lt;101<br>学会利用分号。如：if ( a );else;{   int d;   d = c;}<br>间接转型。如：把double转string，写成new Double(d).toString() 而不是 Double.toString(d)<br>大量使用嵌套。一个NB的程序员可以在一行代码上使用超过10层的小括号（），或是在一个函数里使用超过20层的语句嵌套{}，把嵌套的if else 转成 [? :] 也是一件很NB的事。<br>使用C的变种数组。myArray[i] 可以变成*(myArray + i) 也可以变成 *(i + myArray) 其等价于 i[myArray]。再看一个函数调用的示例，函数声明：int myfunc(int q, int p) { return p%q; } 函数调用myfunc(6291, 8)[Array];<br>长代码行。一行的代码越长越好。这样别人阅读时就需要来来回回的<br>不要较早的return。不要使用goto，不要使用break，这样，你就需要至少5层以上的if-else来处理错误。<br>不要使用{}。不要在if else使用{}，尤其是在你重量地使用if-else嵌套时，你甚至可以在其中乱缩进代码，这样一来，就算是最有经验的程序员也会踩上陷阱。<br>使用宏定义。宏定义绝对是混乱C/C++代码的最佳利器。参看 老手是这样教新手编程的。<br>琐碎的封装。比较封装一个bool类，类里面什么都做，就是一个bool.<br>循环。千万不可用for(int i=0; i&lt;n; i++)使用while代替for，交换n和i，把&lt;改成&lt;=，使用 i–调整步伐 。<br>测试<br>从不测试。千万不要测试任何的出错处理，从来也不检测系统调用的返回值。<br>永远不做性能测试。如果不够快就告诉用户换一个更快的机器。如果你一做测试，那么就可能会要改你的算法，甚至重设计，重新架构。<br>不要写测试案例。不要做什么代码覆盖率测试，自动化测试。<br>测试是懦夫行为。一个勇敢的程序员是根本不需要这一步的。太多的程序太害怕他们的老板，害怕失去工作，害怕用户抱怨，甚至被起诉。这种担心害怕直接影响了生产力。如果你对你的代码有强大的信心，那还要什么测试呢？真正的程序员是不需要测试自己的代码的。<br>其它<br>你的老板什么都知道。无论你的老板有多SB，你都要严格地遵照他的旨意办事，这样一来，你会学到更多的知识如何写出无法维护的代码来的。<br>颠覆Help Desk。你要确保你那满是bug的程序永远不要被维护团队知道。当用户打电话和写邮件给你的时候，你就不要理会，就算要理会，让用户重做系统或是告诉用户其帐号有问题，是标准的回答。<br>闭嘴。对于一些像y2k这样的大bug，你要学会守口如瓶，不要告诉任何人，包括你的亲人好友以及公司的同事和管理层，这样当到那一天的时候，你就可以用这个bug挣钱了。</p>
<p>扒了张有趣的文章，怕挨打，哈哈哈。。。</p>
</article><br><br><span class="next-post"><a href="/2017/06/07/git常用命令/" itemprop="url">上一章 ⇒</a></span><span class="prev-post"><a href="/2018/01/23/类型总结/" itemprop="url">⇐ 下一章 </a></span><br><br><br></main></body></html>